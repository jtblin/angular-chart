{"version":3,"sources":["angular-chart.js"],"names":["factory","exports","module","angular","require","Chart","define","amd","Error","ChartJsProvider","options","responsive","ChartJs","getOptions","type","typeOptions","extend","this","setOptions","customOptions","merge","defaults","$get","ChartJsFactory","$timeout","createChart","scope","elem","getChartOptions","hasData","canDisplay","cvs","ctx","getContext","chartGetColor","getChartColorFn","data","getChartData","destroyChart","chart","$emit","bindEvents","canUpdateChart","newVal","oldVal","length","Array","isArray","every","element","index","reduce","sum","carry","val","getEventHandler","action","triggerOnlyOnChange","lastState","point","points","evt","atEvent","getElementAtEvent","getPointAtEvent","atEvents","getElementsAtEvent","getPointsAtEvent","call","equals","getColors","colors","copy","chartColors","global","notEnoughColors","chartData","push","map","convertColor","color","getColor","rgbStringToRgb","hexToRgb","substr","getRandomColor","getRandomInt","alpha","slice","backgroundColor","rgba","pointBackgroundColor","pointHoverBackgroundColor","borderColor","pointBorderColor","pointHoverBorderColor","min","max","Math","floor","random","useExcanvas","join","concat","hex","bigint","parseInt","r","g","b","match","split","Number","getDataSets","chartLabels","chartSeries","chartDatasetOverride","getData","labels","series","datasetOverride","datasets","item","i","dataset","label","hoverBackgroundColor","chartOptions","onclick","chartClick","noop","onmousemove","chartHover","updateChart","values","forEach","update","isEmpty","value","Object","keys","clientHeight","destroy","restrict","chartType","link","attrs","watch","attribute","fn","checkEquality","attributeValue","attr","onetime","indexOf","watchData","scopeValue","$normalize","$watch","watchOther","watchType","window","G_vmlCanvasManager","initElement","$on","resize","multiTooltipTemplate","tooltips","mode","elements","line","borderWidth","rectangle","legend","display","animation","provider","directive","name"],"mappings":";;;;;;;;;CAAA,SAAAA,GACA,YACA,IAAA,gBAAAC,SAEAC,OAAAD,QAAAD,EACA,mBAAAG,SAAAA,QAAAC,QAAA,WACA,mBAAAC,OAAAA,MAAAD,QAAA,iBACA,IAAA,kBAAAE,SAAAA,OAAAC,IAEAD,QAAA,UAAA,SAAAN,OACA,CAEA,GAAA,mBAAAG,SACA,KAAA,IAAAK,OAAA,uEACA,IAAA,mBAAAH,OACA,KAAA,IAAAG,OAAA,uFAEAR,GAAAG,QAAAE,SAEA,SAAAF,EAAAE,GACA,YA8CA,SAAAI,KACA,GAAAC,IAAAC,YAAA,GACAC,GACAP,MAAAA,EACAQ,WAAA,SAAAC,GACA,GAAAC,GAAAD,GAAAJ,EAAAI,MACA,OAAAX,GAAAa,UAAAN,EAAAK,IAOAE,MAAAC,WAAA,SAAAJ,EAAAK,GAEAA,EAKAT,EAAAI,GAAAX,EAAAiB,MAAAV,EAAAI,OAAAK,IAJAA,EAAAL,EACAJ,EAAAP,EAAAiB,MAAAV,EAAAS,IAMAhB,EAAAiB,MAAAR,EAAAP,MAAAgB,SAAAX,IAGAO,KAAAK,KAAA,WACA,MAAAV,IAIA,QAAAW,GAAAX,EAAAY,GAgFA,QAAAC,GAAAX,EAAAY,EAAAC,GACA,GAAAjB,GAAAkB,EAAAd,EAAAY,EACA,IAAAG,EAAAH,IAAAI,EAAAhB,EAAAY,EAAAC,EAAAjB,GAAA,CAEA,GAAAqB,GAAAJ,EAAA,GACAK,EAAAD,EAAAE,WAAA,KAEAP,GAAAQ,cAAAC,EAAAT,EACA,IAAAU,GAAAC,EAAAvB,EAAAY,EAGAY,GAAAZ,GAEAA,EAAAa,MAAA,GAAA3B,GAAAP,MAAA2B,GACAlB,KAAAA,EACAsB,KAAAA,EACA1B,QAAAA,IAEAgB,EAAAc,MAAA,eAAAd,EAAAa,OACAE,EAAAV,EAAAL,IAGA,QAAAgB,GAAAC,EAAAC,GACA,SAAAD,GAAAC,GAAAD,EAAAE,QAAAD,EAAAC,UACAC,MAAAC,QAAAJ,EAAA,IACAA,EAAAE,SAAAD,EAAAC,QAAAF,EAAAK,MAAA,SAAAC,EAAAC,GACA,MAAAD,GAAAJ,SAAAD,EAAAM,GAAAL,SACAD,EAAAO,OAAAC,EAAA,GAAA,GAAAT,EAAAE,SAAAD,EAAAC,QAKA,QAAAO,GAAAC,EAAAC,GACA,MAAAD,GAAAC,EAGA,QAAAC,GAAA7B,EAAA8B,EAAAC,GACA,GAAAC,IACAC,MAAA,OACAC,OAAA,OAEA,OAAA,UAAAC,GACA,GAAAC,GAAApC,EAAAa,MAAAwB,mBAAArC,EAAAa,MAAAyB,gBACAC,EAAAvC,EAAAa,MAAA2B,oBAAAxC,EAAAa,MAAA4B,gBACA,IAAAF,EAAA,CACA,GAAAL,GAAAK,EAAAG,KAAA1C,EAAAa,MAAAsB,GACAF,EAAAG,EAAAA,EAAAM,KAAA1C,EAAAa,MAAAsB,GAAA,GAAA,MAEAJ,MAAA,IACAtD,EAAAkE,OAAAX,EAAAE,OAAAA,IAAAzD,EAAAkE,OAAAX,EAAAC,MAAAA,MAEAD,EAAAC,MAAAA,EACAD,EAAAE,OAAAA,EACAlC,EAAA8B,GAAAI,EAAAC,EAAAF,MAMA,QAAAW,GAAAxD,EAAAY,GAMA,IALA,GAAA6C,GAAApE,EAAAqE,KAAA9C,EAAA+C,aACA7D,EAAAC,WAAAC,GAAA2D,aACApE,EAAAgB,SAAAqD,OAAAH,QAEAI,EAAAJ,EAAA1B,OAAAnB,EAAAkD,UAAA/B,OACA0B,EAAA1B,OAAAnB,EAAAkD,UAAA/B,QACA0B,EAAAM,KAAAnD,EAAAQ,gBAKA,OADAyC,KAAAjD,EAAA+C,YAAAF,GACAA,EAAAO,IAAAC,GAGA,QAAAA,GAAAC,GAEA,MAAA,gBAAAA,IAAA,MAAAA,EAAA,GAAAC,EAAAC,EAAAF,IAEA,gBAAAA,IAAA,MAAAA,EAAA,GAAAC,EAAAE,EAAAH,EAAAI,OAAA,KAEA,gBAAAJ,IAAA,OAAAA,EAAAA,EACAK,IAGA,QAAAA,KACA,GAAAL,IAAAM,EAAA,EAAA,KAAAA,EAAA,EAAA,KAAAA,EAAA,EAAA,KACA,OAAAL,GAAAD,GAGA,QAAAC,GAAAD,GACA,GAAAO,GAAAP,EAAA,IAAA,CAEA,OADAA,GAAAA,EAAAQ,MAAA,EAAA,IAEAC,gBAAAC,EAAAV,EAAA,IACAW,qBAAAD,EAAAV,EAAAO,GACAK,0BAAAF,EAAAV,EAAA,IACAa,YAAAH,EAAAV,EAAAO,GACAO,iBAAA,OACAC,sBAAAL,EAAAV,EAAAO,IAIA,QAAAD,GAAAU,EAAAC,GACA,MAAAC,MAAAC,MAAAD,KAAAE,UAAAH,EAAAD,EAAA,IAAAA,EAGA,QAAAN,GAAAV,EAAAO,GAEA,MAAAc,GAAA,OAAArB,EAAAsB,KAAA,KAAA,IAAA,QAAAtB,EAAAuB,OAAAhB,GAAAe,KAAA,KAAA,IAIA,QAAAnB,GAAAqB,GACA,GAAAC,GAAAC,SAAAF,EAAA,IACAG,EAAAF,GAAA,GAAA,IACAG,EAAAH,GAAA,EAAA,IACAI,EAAA,IAAAJ,CAEA,QAAAE,EAAAC,EAAAC,GAGA,QAAA3B,GAAAF,GACA,GAAA8B,GAAA9B,EAAA8B,MAAA,uBACA,KAAAA,EAAA,KAAA,IAAAtG,OAAA,yBAEA,OADAwE,GAAA8B,EAAA,GAAAC,MAAA,KACA/B,EAAAF,IAAAkC,QAGA,QAAAnF,GAAAH,GACA,MAAAA,GAAAkD,WAAAlD,EAAAkD,UAAA/B,OAGA,QAAAV,GAAAT,GACA,MAAA,kBAAAA,GAAAQ,cAAAR,EAAAQ,cAAAmD,EAGA,QAAAhD,GAAAvB,EAAAY,GACA,GAAA6C,GAAAD,EAAAxD,EAAAY,EACA,OAAAoB,OAAAC,QAAArB,EAAAkD,UAAA,IACAqC,EAAAvF,EAAAwF,YAAAxF,EAAAkD,UAAAlD,EAAAyF,gBAAA5C,EAAA7C,EAAA0F,sBACAC,EAAA3F,EAAAwF,YAAAxF,EAAAkD,UAAAL,EAAA7C,EAAA0F,sBAGA,QAAAH,GAAAK,EAAAlF,EAAAmF,EAAAhD,EAAAiD,GACA,OACAF,OAAAA,EACAG,SAAArF,EAAA0C,IAAA,SAAA4C,EAAAC,GACA,GAAAC,GAAAzH,EAAAa,UAAAuD,EAAAoD,IACAE,MAAAN,EAAAI,GACAvF,KAAAsF,GAKA,OAHAF,IAAAA,EAAA3E,QAAA8E,GACAxH,EAAAiB,MAAAwG,EAAAJ,EAAAG,IAEAC,KAKA,QAAAP,GAAAC,EAAAlF,EAAAmC,EAAAiD,GACA,GAAAI,IACAN,OAAAA,EACAG,WACArF,KAAAA,EACAqD,gBAAAlB,EAAAO,IAAA,SAAAE,GACA,MAAAA,GAAAW,uBAEAmC,qBAAAvD,EAAAO,IAAA,SAAAE,GACA,MAAAA,GAAAS,oBAOA,OAHA+B,IACArH,EAAAiB,MAAAwG,EAAAH,SAAA,GAAAD,GAEAI,EAGA,QAAAhG,GAAAd,EAAAY,GACA,MAAAvB,GAAAa,UAAAJ,EAAAC,WAAAC,GAAAY,EAAAqG,cAGA,QAAAtF,GAAAV,EAAAL,GACAK,EAAAiG,QAAAtG,EAAAuG,WAAA1E,EAAA7B,EAAA,cAAA,GAAAvB,EAAA+H,KACAnG,EAAAoG,YAAAzG,EAAA0G,WAAA7E,EAAA7B,EAAA,cAAA,GAAAvB,EAAA+H,KAGA,QAAAG,GAAAC,EAAA5G,GACAoB,MAAAC,QAAArB,EAAAkD,UAAA,IACAlD,EAAAa,MAAAH,KAAAqF,SAAAc,QAAA,SAAAX,EAAAD,GACAC,EAAAxF,KAAAkG,EAAAX,KAGAjG,EAAAa,MAAAH,KAAAqF,SAAA,GAAArF,KAAAkG,EAGA5G,EAAAa,MAAAiG,SACA9G,EAAAc,MAAA,eAAAd,EAAAa,OAGA,QAAAkG,GAAAC,GACA,OAAAA,GACA5F,MAAAC,QAAA2F,KAAAA,EAAA7F,QACA,gBAAA6F,KAAAC,OAAAC,KAAAF,GAAA7F,OAGA,QAAAf,GAAAhB,EAAAY,EAAAC,EAAAjB,GAEA,OAAAA,EAAAC,YAAA,IAAAgB,EAAA,GAAAkH,eACArH,EAAA,WACAC,EAAAX,EAAAY,EAAAC,IACA,IAAA,IACA,GAKA,QAAAW,GAAAZ,GACAA,EAAAa,QACAb,EAAAa,MAAAuG,UACApH,EAAAc,MAAA,gBAAAd,EAAAa,QA3SA,MAAA,UAAAzB,GACA,OACAiI,SAAA,KACArH,OACAQ,cAAA,KACA8G,UAAA,IACApE,UAAA,KACAsC,YAAA,KACAa,aAAA,KACAZ,YAAA,KACA1C,YAAA,KACAwD,WAAA,KACAG,WAAA,KACAhB,qBAAA,MAEA6B,KAAA,SAAAvH,EAAAC,EAAAuH,GAoBA,QAAAC,GAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAApJ,EAAA8C,QAAAtB,GAAA6H,KAAAJ,GACAK,EAAAF,GAAA,IAAAA,EAAAG,QAAA,KACAD,IAAAJ,GAAAM,IACAL,GAAA,EAEA,IAAAM,GAAAV,EAAAW,WAAAT,EACA1H,GAAAoI,OAAAF,EAAAP,EAAAC,GAGA,QAAAK,GAAAhH,EAAAC,GACA,IAAAD,IAAAA,EAAAE,QAAAC,MAAAC,QAAAJ,EAAA,MAAAA,EAAA,GAAAE,OAEA,WADAP,GAAAZ,EAGA,IAAAsH,GAAAlI,GAAAY,EAAAsH,SACA,IAAAA,EAEA,MAAAtH,GAAAa,OAAAG,EAAAC,EAAAC,GACAyF,EAAA1F,EAAAjB,OAEAD,GAAAuH,EAAAtH,EAAAC,GAGA,QAAAoI,GAAApH,EAAAC,GACA,IAAA6F,EAAA9F,KACAxC,EAAAkE,OAAA1B,EAAAC,GAAA,CACA,GAAAoG,GAAAlI,GAAAY,EAAAsH,SACAA,IAIAvH,EAAAuH,EAAAtH,EAAAC,IAGA,QAAAqI,GAAArH,EAAAC,GACA6F,EAAA9F,IACAxC,EAAAkE,OAAA1B,EAAAC,IACAnB,EAAAkB,EAAAjB,EAAAC,GAzDA0E,GAAA4D,OAAAC,mBAAAC,YAAAxI,EAAA,IAGAwH,EAAA,aAAAQ,GAAA,GACAR,EAAA,eAAAY,GAAA,GACAZ,EAAA,eAAAY,GAAA,GACAZ,EAAA,gBAAAY,GAAA,GACAZ,EAAA,eAAAY,GAAA,GACAZ,EAAA,yBAAAY,GAAA,GACAZ,EAAA,aAAAa,GAAA,GAEAtI,EAAA0I,IAAA,WAAA,WACA9H,EAAAZ,KAGAA,EAAA0I,IAAA,UAAA,WACA1I,EAAAa,OAAAb,EAAAa,MAAA8H,cA5GAhK,EAAAgB,SAAAqD,OAAA4F,qBAAA,6DACAjK,EAAAgB,SAAAqD,OAAA6F,SAAAC,KAAA,QACAnK,EAAAgB,SAAAqD,OAAA+F,SAAAC,KAAAC,YAAA,EACAtK,EAAAgB,SAAAqD,OAAA+F,SAAAG,UAAAD,YAAA,EACAtK,EAAAgB,SAAAqD,OAAAmG,OAAAC,SAAA,EACAzK,EAAAgB,SAAAqD,OAAAH,QACA,UACA,UACA,UACA,UACA,UACA,UACA,UAGA,IAAA8B,GAAA,gBAAA4D,QAAAC,oBACA,OAAAD,OAAAC,oBACA,kBAAAD,QAAAC,mBAAAC,WAIA,OAFA9D,KAAAhG,EAAAgB,SAAAqD,OAAAqG,WAAA,GAEA5K,EAAAD,OAAA,eACA8K,SAAA,UAAAvK,GACAT,QAAA,kBAAA,UAAA,WAAAuB,IACA0J,UAAA,aAAA,iBAAA,SAAA1J,GAAA,MAAA,IAAAA,MACA0J,UAAA,aAAA,iBAAA,SAAA1J,GAAA,MAAA,IAAAA,GAAA,WACA0J,UAAA,YAAA,iBAAA,SAAA1J,GAAA,MAAA,IAAAA,GAAA,UACA0J,UAAA,sBAAA,iBAAA,SAAA1J,GAAA,MAAA,IAAAA,GAAA,oBACA0J,UAAA,cAAA,iBAAA,SAAA1J,GAAA,MAAA,IAAAA,GAAA,YACA0J,UAAA,iBAAA,iBAAA,SAAA1J,GAAA,MAAA,IAAAA,GAAA,eACA0J,UAAA,YAAA,iBAAA,SAAA1J,GAAA,MAAA,IAAAA,GAAA,UACA0J,UAAA,kBAAA,iBAAA,SAAA1J,GAAA,MAAA,IAAAA,GAAA,gBACA0J,UAAA,eAAA,iBAAA,SAAA1J,GAAA,MAAA,IAAAA,GAAA,aACA2J","file":"angular-chart.min.js","sourcesContent":["(function (factory) {\r\n  'use strict';\r\n  if (typeof exports === 'object') {\r\n    // Node/CommonJS\r\n    module.exports = factory(\r\n      typeof angular !== 'undefined' ? angular : require('angular'),\r\n      typeof Chart !== 'undefined' ? Chart : require('chart.js'));\r\n  }  else if (typeof define === 'function' && define.amd) {\r\n    // AMD. Register as an anonymous module.\r\n    define(['angular', 'chart'], factory);\r\n  } else {\r\n    // Browser globals\r\n    if (typeof angular === 'undefined') {\r\n        throw new Error('AngularJS framework needs to be included, see https://angularjs.org/');\r\n    } else if (typeof Chart === 'undefined') {\r\n      throw new Error('Chart.js library needs to be included, see http://jtblin.github.io/angular-chart.js/');\r\n    }\r\n    factory(angular, Chart);\r\n  }\r\n}(function (angular, Chart) {\r\n  'use strict';\r\n\r\n  Chart.defaults.global.multiTooltipTemplate = '<%if (datasetLabel){%><%=datasetLabel%>: <%}%><%= value %>';\r\n  Chart.defaults.global.tooltips.mode = 'label';\r\n  Chart.defaults.global.elements.line.borderWidth = 2;\r\n  Chart.defaults.global.elements.rectangle.borderWidth = 2;\r\n  Chart.defaults.global.legend.display = false;\r\n  Chart.defaults.global.colors = [\r\n    '#97BBCD', // blue\r\n    '#DCDCDC', // light grey\r\n    '#F7464A', // red\r\n    '#46BFBD', // green\r\n    '#FDB45C', // yellow\r\n    '#949FB1', // grey\r\n    '#4D5360'  // dark grey\r\n  ];\r\n\r\n  var useExcanvas = typeof window.G_vmlCanvasManager === 'object' &&\r\n    window.G_vmlCanvasManager !== null &&\r\n    typeof window.G_vmlCanvasManager.initElement === 'function';\r\n\r\n  if (useExcanvas) Chart.defaults.global.animation = false;\r\n\r\n  return angular.module('chart.js', [])\r\n    .provider('ChartJs', ChartJsProvider)\r\n    .factory('ChartJsFactory', ['ChartJs', '$timeout', ChartJsFactory])\r\n    .directive('chartBase', ['ChartJsFactory', function (ChartJsFactory) { return new ChartJsFactory(); }])\r\n    .directive('chartLine', ['ChartJsFactory', function (ChartJsFactory) { return new ChartJsFactory('line'); }])\r\n    .directive('chartBar', ['ChartJsFactory', function (ChartJsFactory) { return new ChartJsFactory('bar'); }])\r\n    .directive('chartHorizontalBar', ['ChartJsFactory', function (ChartJsFactory) { return new ChartJsFactory('horizontalBar'); }])\r\n    .directive('chartRadar', ['ChartJsFactory', function (ChartJsFactory) { return new ChartJsFactory('radar'); }])\r\n    .directive('chartDoughnut', ['ChartJsFactory', function (ChartJsFactory) { return new ChartJsFactory('doughnut'); }])\r\n    .directive('chartPie', ['ChartJsFactory', function (ChartJsFactory) { return new ChartJsFactory('pie'); }])\r\n    .directive('chartPolarArea', ['ChartJsFactory', function (ChartJsFactory) { return new ChartJsFactory('polarArea'); }])\r\n    .directive('chartBubble', ['ChartJsFactory', function (ChartJsFactory) { return new ChartJsFactory('bubble'); }])\r\n    .name;\r\n\r\n  /**\r\n   * Wrapper for chart.js\r\n   * Allows configuring chart js using the provider\r\n   *\r\n   * angular.module('myModule', ['chart.js']).config(function(ChartJsProvider) {\r\n   *   ChartJsProvider.setOptions({ responsive: false });\r\n   *   ChartJsProvider.setOptions('Line', { responsive: true });\r\n   * })))\r\n   */\r\n  function ChartJsProvider () {\r\n    var options = { responsive: true };\r\n    var ChartJs = {\r\n      Chart: Chart,\r\n      getOptions: function (type) {\r\n        var typeOptions = type && options[type] || {};\r\n        return angular.extend({}, options, typeOptions);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Allow to set global options during configuration\r\n     */\r\n    this.setOptions = function (type, customOptions) {\r\n      // If no type was specified set option for the global object\r\n      if (! customOptions) {\r\n        customOptions = type;\r\n        options = angular.merge(options, customOptions);\r\n      } else {\r\n        // Set options for the specific chart\r\n        options[type] = angular.merge(options[type] || {}, customOptions);\r\n      }\r\n\r\n      angular.merge(ChartJs.Chart.defaults, options);\r\n    };\r\n\r\n    this.$get = function () {\r\n      return ChartJs;\r\n    };\r\n  }\r\n\r\n  function ChartJsFactory (ChartJs, $timeout) {\r\n    return function chart (type) {\r\n      return {\r\n        restrict: 'CA',\r\n        scope: {\r\n          chartGetColor: '=?',\r\n          chartType: '=',\r\n          chartData: '=?',\r\n          chartLabels: '=?',\r\n          chartOptions: '=?',\r\n          chartSeries: '=?',\r\n          chartColors: '=?',\r\n          chartClick: '=?',\r\n          chartHover: '=?',\r\n          chartDatasetOverride: '=?'\r\n        },\r\n        link: function (scope, elem, attrs) {\r\n          if (useExcanvas) window.G_vmlCanvasManager.initElement(elem[0]);\r\n\r\n          // Order of setting \"watch\" matter\r\n          watch('chart-data', watchData, true);\r\n          watch('chart-series', watchOther, true);\r\n          watch('chart-labels', watchOther, true);\r\n          watch('chart-options', watchOther, true);\r\n          watch('chart-colors', watchOther, true);\r\n          watch('chart-dataset-override', watchOther, true);\r\n          watch('chart-type', watchType, false);\r\n\r\n          scope.$on('$destroy', function () {\r\n            destroyChart(scope);\r\n          });\r\n\r\n          scope.$on('$resize', function () {\r\n            if (scope.chart) scope.chart.resize();\r\n          });\r\n\r\n          function watch(attribute, fn, checkEquality) {\r\n            var attributeValue = angular.element(elem).attr(attribute);\r\n            var onetime = attributeValue && attributeValue.indexOf('::') === 0;\r\n            if(onetime && fn != watchData) {\r\n              checkEquality = false;\r\n            }\r\n            var scopeValue = attrs.$normalize(attribute);\r\n            scope.$watch(scopeValue, fn, checkEquality);\r\n          }\r\n\r\n          function watchData (newVal, oldVal) {\r\n            if (! newVal || ! newVal.length || (Array.isArray(newVal[0]) && ! newVal[0].length)) {\r\n              destroyChart(scope);\r\n              return;\r\n            }\r\n            var chartType = type || scope.chartType;\r\n            if (! chartType) return;\r\n\r\n            if (scope.chart && canUpdateChart(newVal, oldVal))\r\n              return updateChart(newVal, scope);\r\n\r\n            createChart(chartType, scope, elem);\r\n          }\r\n\r\n          function watchOther (newVal, oldVal) {\r\n            if (isEmpty(newVal)) return;\r\n            if (angular.equals(newVal, oldVal)) return;\r\n            var chartType = type || scope.chartType;\r\n            if (! chartType) return;\r\n\r\n            // chart.update() doesn't work for series and labels\r\n            // so we have to re-create the chart entirely\r\n            createChart(chartType, scope, elem);\r\n          }\r\n\r\n          function watchType (newVal, oldVal) {\r\n            if (isEmpty(newVal)) return;\r\n            if (angular.equals(newVal, oldVal)) return;\r\n            createChart(newVal, scope, elem);\r\n          }\r\n        }\r\n      };\r\n    };\r\n\r\n    function createChart (type, scope, elem) {\r\n      var options = getChartOptions(type, scope);\r\n      if (! hasData(scope) || ! canDisplay(type, scope, elem, options)) return;\r\n\r\n      var cvs = elem[0];\r\n      var ctx = cvs.getContext('2d');\r\n\r\n      scope.chartGetColor = getChartColorFn(scope);\r\n      var data = getChartData(type, scope);\r\n      // Destroy old chart if it exists to avoid ghost charts issue\r\n      // https://github.com/jtblin/angular-chart.js/issues/187\r\n      destroyChart(scope);\r\n\r\n      scope.chart = new ChartJs.Chart(ctx, {\r\n        type: type,\r\n        data: data,\r\n        options: options\r\n      });\r\n      scope.$emit('chart-create', scope.chart);\r\n      bindEvents(cvs, scope);\r\n    }\r\n\r\n    function canUpdateChart (newVal, oldVal) {\r\n      if (newVal && oldVal && newVal.length && oldVal.length) {\r\n        return Array.isArray(newVal[0]) ?\r\n        newVal.length === oldVal.length && newVal.every(function (element, index) {\r\n          return element.length === oldVal[index].length; }) :\r\n          oldVal.reduce(sum, 0) > 0 ? newVal.length === oldVal.length : false;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    function sum (carry, val) {\r\n      return carry + val;\r\n    }\r\n\r\n    function getEventHandler (scope, action, triggerOnlyOnChange) {\r\n      var lastState = {\r\n        point: void 0,\r\n        points: void 0\r\n      };\r\n      return function (evt) {\r\n        var atEvent = scope.chart.getElementAtEvent || scope.chart.getPointAtEvent;\r\n        var atEvents = scope.chart.getElementsAtEvent || scope.chart.getPointsAtEvent;\r\n        if (atEvents) {\r\n          var points = atEvents.call(scope.chart, evt);\r\n          var point = atEvent ? atEvent.call(scope.chart, evt)[0] : void 0;\r\n\r\n          if (triggerOnlyOnChange === false ||\r\n            (! angular.equals(lastState.points, points) && ! angular.equals(lastState.point, point))\r\n          ) {\r\n            lastState.point = point;\r\n            lastState.points = points;\r\n            scope[action](points, evt, point);\r\n          }\r\n        }\r\n      };\r\n    }\r\n\r\n    function getColors (type, scope) {\r\n      var colors = angular.copy(scope.chartColors ||\r\n        ChartJs.getOptions(type).chartColors ||\r\n        Chart.defaults.global.colors\r\n      );\r\n      var notEnoughColors = colors.length < scope.chartData.length;\r\n      while (colors.length < scope.chartData.length) {\r\n        colors.push(scope.chartGetColor());\r\n      }\r\n      // mutate colors in this case as we don't want\r\n      // the colors to change on each refresh\r\n      if (notEnoughColors) scope.chartColors = colors;\r\n      return colors.map(convertColor);\r\n    }\r\n\r\n    function convertColor (color) {\r\n      // Allows RGB and RGBA colors to be input as a string: e.g.: \"rgb(159,204,0)\", \"rgba(159,204,0, 0.5)\"\r\n      if (typeof color === 'string' && color[0] === 'r') return getColor(rgbStringToRgb(color));\r\n      // Allows hex colors to be input as a string.\r\n      if (typeof color === 'string' && color[0] === '#') return getColor(hexToRgb(color.substr(1)));\r\n      // Allows colors to be input as an object, bypassing getColor() entirely\r\n      if (typeof color === 'object' && color !== null) return color;\r\n      return getRandomColor();\r\n    }\r\n\r\n    function getRandomColor () {\r\n      var color = [getRandomInt(0, 255), getRandomInt(0, 255), getRandomInt(0, 255)];\r\n      return getColor(color);\r\n    }\r\n\r\n    function getColor (color) {\r\n      var alpha = color[3] || 1;\r\n      color = color.slice(0, 3);\r\n      return {\r\n        backgroundColor: rgba(color, 0.2),\r\n        pointBackgroundColor: rgba(color, alpha),\r\n        pointHoverBackgroundColor: rgba(color, 0.8),\r\n        borderColor: rgba(color, alpha),\r\n        pointBorderColor: '#fff',\r\n        pointHoverBorderColor: rgba(color, alpha)\r\n      };\r\n    }\r\n\r\n    function getRandomInt (min, max) {\r\n      return Math.floor(Math.random() * (max - min + 1)) + min;\r\n    }\r\n\r\n    function rgba (color, alpha) {\r\n      // rgba not supported by IE8\r\n      return useExcanvas ? 'rgb(' + color.join(',') + ')' : 'rgba(' + color.concat(alpha).join(',') + ')';\r\n    }\r\n\r\n    // Credit: http://stackoverflow.com/a/11508164/1190235\r\n    function hexToRgb (hex) {\r\n      var bigint = parseInt(hex, 16),\r\n        r = (bigint >> 16) & 255,\r\n        g = (bigint >> 8) & 255,\r\n        b = bigint & 255;\r\n\r\n      return [r, g, b];\r\n    }\r\n\r\n    function rgbStringToRgb (color) {\r\n      var match = color.match(/^rgba?\\(([\\d,.]+)\\)$/);\r\n      if (! match) throw new Error('Cannot parse rgb value');\r\n      color = match[1].split(',');\r\n      return color.map(Number);\r\n    }\r\n\r\n    function hasData (scope) {\r\n      return scope.chartData && scope.chartData.length;\r\n    }\r\n\r\n    function getChartColorFn (scope) {\r\n      return typeof scope.chartGetColor === 'function' ? scope.chartGetColor : getRandomColor;\r\n    }\r\n\r\n    function getChartData (type, scope) {\r\n      var colors = getColors(type, scope);\r\n      return Array.isArray(scope.chartData[0]) ?\r\n        getDataSets(scope.chartLabels, scope.chartData, scope.chartSeries || [], colors, scope.chartDatasetOverride) :\r\n        getData(scope.chartLabels, scope.chartData, colors, scope.chartDatasetOverride);\r\n    }\r\n\r\n    function getDataSets (labels, data, series, colors, datasetOverride) {\r\n      return {\r\n        labels: labels,\r\n        datasets: data.map(function (item, i) {\r\n          var dataset = angular.extend({}, colors[i], {\r\n            label: series[i],\r\n            data: item\r\n          });\r\n          if (datasetOverride && datasetOverride.length >= i) {\r\n            angular.merge(dataset, datasetOverride[i]);\r\n          }\r\n          return dataset;\r\n        })\r\n      };\r\n    }\r\n\r\n    function getData (labels, data, colors, datasetOverride) {\r\n      var dataset = {\r\n        labels: labels,\r\n        datasets: [{\r\n          data: data,\r\n          backgroundColor: colors.map(function (color) {\r\n            return color.pointBackgroundColor;\r\n          }),\r\n          hoverBackgroundColor: colors.map(function (color) {\r\n            return color.backgroundColor;\r\n          })\r\n        }]\r\n      };\r\n      if (datasetOverride) {\r\n        angular.merge(dataset.datasets[0], datasetOverride);\r\n      }\r\n      return dataset;\r\n    }\r\n\r\n    function getChartOptions (type, scope) {\r\n      return angular.extend({}, ChartJs.getOptions(type), scope.chartOptions);\r\n    }\r\n\r\n    function bindEvents (cvs, scope) {\r\n      cvs.onclick = scope.chartClick ? getEventHandler(scope, 'chartClick', false) : angular.noop;\r\n      cvs.onmousemove = scope.chartHover ? getEventHandler(scope, 'chartHover', true) : angular.noop;\r\n    }\r\n\r\n    function updateChart (values, scope) {\r\n      if (Array.isArray(scope.chartData[0])) {\r\n        scope.chart.data.datasets.forEach(function (dataset, i) {\r\n          dataset.data = values[i];\r\n        });\r\n      } else {\r\n        scope.chart.data.datasets[0].data = values;\r\n      }\r\n\r\n      scope.chart.update();\r\n      scope.$emit('chart-update', scope.chart);\r\n    }\r\n\r\n    function isEmpty (value) {\r\n      return ! value ||\r\n        (Array.isArray(value) && ! value.length) ||\r\n        (typeof value === 'object' && ! Object.keys(value).length);\r\n    }\r\n\r\n    function canDisplay (type, scope, elem, options) {\r\n      // TODO: check parent?\r\n      if (options.responsive && elem[0].clientHeight === 0) {\r\n        $timeout(function () {\r\n          createChart(type, scope, elem);\r\n        }, 50, false);\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    function destroyChart(scope) {\r\n      if(! scope.chart) return;\r\n      scope.chart.destroy();\r\n      scope.$emit('chart-destroy', scope.chart);\r\n    }\r\n  }\r\n}));\r\n"]}